% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hawkes_em_functions.R
\name{compute_I}
\alias{compute_I}
\title{Compute the intensity functions for a Hawkes process.}
\usage{
compute_I(out, inp, pp_obj, parms, k, Log = F)
}
\arguments{
\item{out}{index for which component of \code{pp} object is the output process.}

\item{inp}{index for which component of \code{pp} object is the input process.}

\item{pp_obj}{a \code{pp} object.}

\item{parms}{parameters of the Hawkes process formatted as described for \code{set_parms}.}

\item{k}{optional: output from \code{set_kernel(kernel_type)}. Currently only implemented for \code{kernel_type = "dgamma"}.}

\item{Log}{logical: return \code{alpha*kernel} or \code{log(alpha) + log(kernel)} ?}
}
\value{
A named list with components \code{c("Intensity", "Compensator", "Parents")}, each of which are lists with \code{length(pp_obj[[out]])} components. \code{"Intensity"} contains the non-zero intensities for each output event, and \code{"Parents"} contains the parent index (i.e., from \code{pp_obj[[inp]])} for each value in \code{"Intensity"}. Similarly for \code{"Compensator"}.
}
\description{
For each event in an output process, compute its intensity under each event in an input process. This is the main workhorse of both the E and M step. Note that the return fromat would more intuitively be represented as n_output_events by n_input_events matrix, but this gets very large and sparse for longer time series. So instead of a matrix, the output is fromated two lists, each being itself a list of length n_output_events -- one list contains intensities, the other the indices, for input events that have non-negligible intensity. This is less intuitive in terms of storage but substantially faster (linear versus quadratic computational complexity; see Halpin 2013).
}
